# js基础概念

## ES6常用新特性

### let和块级作用域

#### let变量的特性
- let没有`变量提升`，必须先声明再使用，否则报错（而不是`undefined`）。
- 不能重复声明（而不是最后声明的值被赋值成功）。

#### 块级作用域
let变量只在当前代码块内可以访问，比如一个循环或者一个函数等都是一个代码块。或者说，`成对花括号内`部即为一个代码块。

let关键字可以取代以前用“立即执行函数”来模拟块级作用域的场景：

```js
// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
```

避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

```js
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
```

### const变量

用于声明只读的变量。所以必须在声明的时候进行初始化。先声明后使用，不可重复声明。

**深入理解**
const实际是保证变量地址不变，所以在简单类型上可以保证值不变，但是在引用类型上，情况有些不一样。对应const声明的引用类型，实际上是保证了指针的地址，所以可以改变属性值，但是不能重新赋值。

备注：使用`Object.freeze`方法可以使对象属性也不可更改。
备注2：如果被冻结的对象中包含另一个对象，需要在该对象上面再次执行`freeze`。下面是一个将对象彻底冻结的函数。

```js
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
```

#### 认识顶级对象

- 浏览器：window、self
- web worker：self
- node：global

### 解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

`...`扩展运算符，可以简化数组数值，简化函数传参。

对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。